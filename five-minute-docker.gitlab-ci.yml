stages:
    - build
    - deploy
    - destroy

variables:
    TF_VAR_AWS_ACCESS_KEY: ${AWS_ACCESS_KEY}
    TF_VAR_AWS_SECRET_KEY: ${AWS_SECRET_KEY}
    TF_VAR_AWS_REGION: ${AWS_REGION}
    TF_VAR_AWS_EC2_AMI: "ami-03657b56516ab7912" # Amazon Linux 2 SSD Volume Type
    TF_VAR_ENVIRONMENT_NAME: ${CI_PROJECT_PATH_SLUG}_${CI_PROJECT_ID}_${CI_COMMIT_REF_SLUG}
    TF_ADDRESS: ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${CI_COMMIT_REF_SLUG}

cache:
    paths:
        - .terraform

Docker Build Push:
    stage: build
    image: docker:stable
    services:
        - docker:stable-dind
    variables:
        IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
    script:
        - docker login --username $CI_REGISTRY_USER --password $CI_REGISTRY_PASSWORD $CI_REGISTRY_IMAGE
        - docker build . --tag $IMAGE_TAG
        - docker push $IMAGE_TAG

AWS Provision:
    stage: build
    image: registry.gitlab.com/gitlab-org/terraform-images/stable:latest
    script:
        - wget https://gitlab.com/gitlab-org/creator-pairing/5-minute-prod-app/sri-stuff/five-minute-docker/-/raw/master/infra.tf
        - gitlab-terraform init
        - gitlab-terraform plan -lock=false
        - gitlab-terraform plan-json -lock=false
        - gitlab-terraform apply -lock=false
    artifacts:
        paths:
            - infra.tf
        reports:
            terraform: plan.json

Deploy App:
    stage: deploy
    image: registry.gitlab.com/gitlab-org/terraform-images/stable:latest
    script:
        - export WEBAPP_PORT=${WEBAPP_PORT:-5000}
        - export DB_INITIALIZE=${DB_INITIALIZE:-'echo "DB_INITIALIZE not set"'}
        - export DB_MIGRATE=${DB_MIGRATE:-'echo "DB_MIGRATE not set"'}
        - gitlab-terraform output -json > tmp_tf_output.json
        - cat tmp_tf_output.json | jq --raw-output ".public_ip.value"                   > tmp_public_ip.txt
        - cat tmp_tf_output.json | jq --raw-output ".private_key.value.private_key_pem" > tmp_private_key.pem
        - cat tmp_tf_output.json | jq --raw-output ".database_url.value"                > tmp_database_url.txt
        - chmod 0600 tmp_private_key.pem
        - DYNAMIC_ENVIRONMENT_URL=$(cat tmp_public_ip.txt)
        - echo "DYNAMIC_ENVIRONMENT_URL=$DYNAMIC_ENVIRONMENT_URL" >> deploy.env
        - ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i tmp_private_key.pem ec2-user@$(cat tmp_public_ip.txt) "uname --all"
        - ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i tmp_private_key.pem ec2-user@$(cat tmp_public_ip.txt) "sudo amazon-linux-extras install docker"
        - ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i tmp_private_key.pem ec2-user@$(cat tmp_public_ip.txt) "sudo service docker start"
        - ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i tmp_private_key.pem ec2-user@$(cat tmp_public_ip.txt) "sudo docker login --username $CI_REGISTRY_USER --password $CI_REGISTRY_PASSWORD $CI_REGISTRY_IMAGE"
        - ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i tmp_private_key.pem ec2-user@$(cat tmp_public_ip.txt) 'sudo docker container stop $(sudo docker container ps -aq) || echo "No running containers"'
        - ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i tmp_private_key.pem ec2-user@$(cat tmp_public_ip.txt) 'sudo docker container rm $(sudo docker container ps -aq) || echo "No existing containers"'
        - ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i tmp_private_key.pem ec2-user@$(cat tmp_public_ip.txt) "sudo docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG"
        - ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i tmp_private_key.pem ec2-user@$(cat tmp_public_ip.txt) "sudo docker run --name container_webapp -e DATABASE_URL=$(cat tmp_database_url.txt) -d -p 80:$WEBAPP_PORT $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG"
        - ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i tmp_private_key.pem ec2-user@$(cat tmp_public_ip.txt) "sudo docker exec -e DATABASE_URL=$(cat tmp_database_url.txt) -i container_webapp $DB_INITIALIZE"
        - ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -i tmp_private_key.pem ec2-user@$(cat tmp_public_ip.txt) "sudo docker exec -e DATABASE_URL=$(cat tmp_database_url.txt) -i container_webapp $DB_MIGRATE"
    artifacts:
        reports:
            dotenv: deploy.env
    environment:
        name: $CI_COMMIT_REF_SLUG
        url: http://$DYNAMIC_ENVIRONMENT_URL

Destroy:
    stage: destroy
    image: registry.gitlab.com/gitlab-org/terraform-images/stable:latest
    when: manual
    script:
        - gitlab-terraform destroy -auto-approve -lock=false
